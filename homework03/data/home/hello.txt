OrderByNameIterator(Folder* composite, int operationCount) : _host(composite), _operationCount(operationCount)  {
            // std::cout << "OrderByNameIterator\n" << std::endl;
            Iterator * it = _host->createIterator();
            for (it->first(); !it->isDone(); it->next()) {
                _nodes.push_back(it->currentItem());
            }
            _nodes.sort([](Node * a, Node * b) {
                return a->name() < b->name();
            });

            for (it->first(); !it->isDone(); it->next()) {
                // std::cout << it->currentItem()->name() << std::endl;

                struct stat fileInfo;
                string path = it->currentItem()->path(); 
                const char* c = path.c_str(); 
                // std::cout << "path:" << c << "\n"; 
                lstat(c, &fileInfo);
                if(lstat(c, &fileInfo) == 0){
                    if(S_ISDIR(fileInfo.st_mode)) {
                        // if it is a folder
                        // std::cout << "Folder: " << currentItem()->name() << std::endl;
                        Iterator * it2 = it->currentItem()->createIterator(OrderBy::Name);
                        for (it2->first(); !it2->isDone(); it2->next()) {
                            _nodes.push_back(it2->currentItem()); 
                        }
                    }
                }
            }
            


            
        }

         ~OrderByNameIterator() {}

        void first() {
            checkAvailable();
            _current = _nodes.begin();
        }

        Node * currentItem() const {
            return *_current;
        }

        void next() {
            checkAvailable();
            // std::cout << "currentItem()->name(): " << currentItem()->path() << std::endl;

            // struct stat fileInfo;
            // string path = currentItem()->path(); 
            // const char* c = path.c_str(); 
            // // std::cout << "path:" << c << "\n"; 
            // lstat(c, &fileInfo);
            // if(lstat(c, &fileInfo) == 0){
            //     if(S_ISDIR(fileInfo.st_mode)) {
            //         // if it is a folder
            //         // std::cout << "Folder: " << currentItem()->name() << std::endl;
            //         Iterator * it = currentItem()->createIterator(OrderBy::Name);
            //         for (it->first(); !it->isDone(); it->next()) {
            //             // _nodes.push_back(it->currentItem());
            //         }
            //     }
            // }
            _current++;
        }

        bool isDone() const {
            return _current == _nodes.end();
        }

    private:
        Folder* const _host;
        std::list<Node *>::iterator _current;
        std::list<Node *>::iterator _temp;
        std::list<Node *> _nodes;
        int _operationCount;

        void checkAvailable() const {
            if(_host->_operationCount != _operationCount) {
                throw "Iterator Not Avaliable";
            }
        }
    };

    -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/


    #pragma once 

#include <list>
#include <queue>
#include <string>
#include <iostream>
#include <sys/stat.h>

#include "node.h"
#include "order_by.h"
#include "iterator.h"

using namespace std;

class Folder: public Node {
private:
    list<Node *> _nodes;
    int _operationCount = 0;

protected:
    void removeChild(Node * target) override {
        _nodes.remove(target);
        _operationCount++;
    }

public:
    Folder(string path): Node(path) {
        struct stat fileInfo;
        const char *c = path.c_str();
        if(lstat(c, &fileInfo) == 0){
            if(S_ISDIR(fileInfo.st_mode))
                return;
        }
        throw "No Folder exists";
    }

    void add(Node * node) override {
        if (node->path() != this->path() + "/" + node->name()) {
            throw string("Incorrect path of node: " + node -> path());
        }
        _nodes.push_back(node);
        node->parent(this);
        _operationCount++;
    }

    Node * getChildByName(const char * name) const override {
        for (auto it = _nodes.begin(); it != _nodes.end(); ++it) {
            if ((*it)->name() == name) {
                return *it;
            }
        }

        return nullptr;
    }

    int numberOfFiles() const override {
        int num = 0;
        if (_nodes.size() == 0) {
            return 0;
        }
        for (auto it = _nodes.begin(); it != _nodes.end(); ++it) {
            num += (*it)->numberOfFiles();
        }
        return num;
    }

    Iterator * createIterator() override {
        return new FolderIterator(this, _operationCount);
    }

    Iterator * createIterator(OrderBy orderby) override {
        if (orderby == OrderBy::Normal) {
            // std::cout << "Normal in createIterator" << std::endl;
            return new FolderIterator(this, _operationCount);
        } else if (orderby == OrderBy::Name) {
            // std::cout << "Name in createIterator" << std::endl;
            return new OrderByNameIterator(this, _operationCount);
        } else if (orderby == OrderBy::NameWithFolderFirst) {
            std::cout << "NameWithFolderFirst in createIterator" << std::endl;
            return new NullIterator();
        } else if (orderby == OrderBy::Kind) {
            std::cout << "Kind in createIterator" << std::endl;
            return new NullIterator();
        } 
        return new NullIterator();
    }

    Node * find(string path) override {
        if (this->path() == path) {
            return this;
        }

        size_t index = path.find(this->path());

        if (string::npos == index) {
            return nullptr;
        }

        for (auto it = _nodes.begin(); it != _nodes.end(); ++it) {
            Node * result = (*it)->find(path);
            if (result) {
                return result;
            }
        }
        return nullptr;
    }

    std::list<string> findByName(string name) override {
        std::list<string> pathList;
        if (this->name() == name) {
            pathList.push_back(this->path());
        }

        for (auto it = _nodes.begin(); it != _nodes.end(); ++it) {
            std::list<string> paths = (*it)->findByName(name);
            for (auto i = paths.begin(); i != paths.end(); i++)
            {
                pathList.push_back(*i);  
            }
        }

        return pathList;
    }

    void remove(string path) override {
        Node * target = find(path);
        if (target) {
            target->parent()->removeChild(target);
        }
    }

    void accept(Visitor * visitor) override {
        visitor->visitFolder(this);
    }

    class FolderIterator : public Iterator {
    public:
        FolderIterator(Folder* composite, int operationCount) : _host(composite), _operationCount(operationCount)  {}

        ~FolderIterator() {}

        void first() {
            checkAvailable();
            _current = _host->_nodes.begin();
        }

        Node * currentItem() const {
            return *_current;
        }

        void next() {
            checkAvailable();
            _current++;
        }

        bool isDone() const {
            return _current == _host->_nodes.end();
        }

    private:
        Folder* const _host;
        std::list<Node *>::iterator _current;
        int _operationCount;

        void checkAvailable() const {
            if(_host->_operationCount != _operationCount) {
                throw "Iterator Not Avaliable";
            }
        }
    };

    class OrderByNameIterator: public Iterator {
    public:
        OrderByNameIterator(Folder* composite, int operationCount) : _host(composite), _operationCount(operationCount)  {
            // std::cout << "OrderByNameIterator\n" << std::endl;
            Iterator * it = _host->createIterator();
            for (it->first(); !it->isDone(); it->next()) {
                // std::cout << "aaa " << it->currentItem()->name() << std::endl;
                _nodes.push_back(it->currentItem());
            }
            _nodes.sort([](Node * a, Node * b) {
                return a->name() < b->name();
            });

            for (auto it = _nodes.begin(); it != _nodes.end(); ++it) {
                std::cout << (*it)->name() << std::endl;
                if(isFolder((*it)->path())){
                    // std::cout << "Folder: " << this->currentItem()->name() << std::endl;
                    Iterator * it2 = (*it)->createIterator(OrderBy::Name);
                    // it2->first();
                    _queue.push(it2);
                }
            }
        }

         ~OrderByNameIterator() {}

        void first() {
            checkAvailable();
            _current = _nodes.begin();
            _currentItem = *_current;
        }

        Node * currentItem() const {
            return _currentItem;
        }

        void next() {
            checkAvailable();
            if (isFolder(currentItem()->path())) {
                std::cout << "isFolder" << std::endl;
                _queue.front()->first();
                if(!_queue.empty()){
                    if (_queue.front()->isDone()) {
                        std::cout << "queue.front is done" << std::endl;
                        _queue.pop();
                        _current++;
                        _currentItem = *_current;
                    }else{
                        _queue.front()->next();
                        _currentItem = _queue.front()->currentItem();
                    }
                }
            }else{
                _current++;
                _currentItem = *_current;
            }
        }

        bool isDone() const {
            return _current == _nodes.end();
        }

    private:
        Folder* const _host;
        Node * _currentItem;
        std::list<Node *>::iterator _current;
        std::queue<Iterator *> _queue;
        std::list<Node *> _nodes;
        int _operationCount;

        void checkAvailable() const {
            if(_host->_operationCount != _operationCount) {
                throw "Iterator Not Avaliable";
            }
        }

        bool isFolder(string path){
            struct stat fileInfo;
            const char *c = path.c_str();
            if(lstat(c, &fileInfo) == 0){
                if(S_ISDIR(fileInfo.st_mode))
                    return true;
            }
            return false;
        }
    };

    class OrderByNameWithFolderFirstIterator: public Iterator {
    
    };

    class OrderByKindIterator: public Iterator {
    
    };
};
